# 知识点记录

> React+Ts+antd 技术栈

## React

### React.memo

高阶组件，如果组件在相同的 props 下渲染出相同的结果，使用这个方法处理之后直接复用最近一次的渲染的结果，是一个性能优化的处理方式。

一般子组件最好都是需要使用这个方法处理一下，避免子组件不必要的渲染。

- memo 只检查 props 变成，如果是 useState 之类的变更，它仍会重新渲染

```js
function MyComponent(props) {
	/* 使用 props 渲染 */
}
function areEqual(prevProps, nextProps) {
	/*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */
}
export default React.memo(MyComponent, areEqual)
```

#### useModule

UmiJs 的一个 hook，提供消费 Model 能力，相当于是处理全局状态，跨组件通信方式。

useModule 有两个参数，namespace 和 updater。

- `namespace` - 就是 hooks model 文件的文件名，如上面例子里的 `useAuthModel`
- `updater` - 可选参数。在 hooks model 返回多个状态，但使用组件仅引用了其中部分状态，并且希望仅在这几个状态更新时 rerender 时使用（性能相关）。

```js
import { useModel } from 'umi'

export default () => {
	const { user, fetchUser } = useModel('user', model => ({
		user: model.user,
		fetchUser: model.fetchUser,
	}))
	return <>hello</>
}
```

**在项目中使用案例**

```js
// models文件夹中创建一个dzInfo.ts
import { useState } from 'react';

export default function useDzInfo() {
  const [info, setInfo] = useState({ name: 'Jimmy', love: 'xuexue' });
  return {
    ...info,
    setInfo,
  };
}

// 在其他的任意组件内部使用
import { useModel, memo } from 'umi';
export default memo(()=>{
  const { name, love, setInfo } = useModel('dzInfo')
  return (
    <div>hello world</div>
  )
})
```

## TypeScript

#### 强制类型转换

umi 提供了一个`useLocation`钩子，再钩子可以返回路由对象信息，其中就有 query 查询参信息，但是在项目中直接写会报错提示找不到 query 参数。但是实际上我们可以获取到这个参数，为了解决这个问题可以使用强制类型转换，先转成 unkonow 类型，再转成我们想要的类型。

```js
import { memo, useState } from 'react';
import { useLocation, Location } from 'umi';

type dz = {
  query:{
    cardId:number
  }
}

export default memo(()=>{
  const { query } = useLocation() // ts类型报错
  // 解决方式1（不太好） 只有query 其他的属性不能访问了 如 pathname
  const { query } = useLocation() as unknow as {
    query:{
      cardId:number
    }
  }
  // 解决方式2（推荐） location 的其他属性 如 pathname 仍然可以正常访问
  const { query } = useLocation() as Location & dz
})
```

- & 符号在 ts 中表示类型的联合

  Location & dz 等于在 Location 类型的基础上加上 dz 这个类型

#### 强制有值

ts 一个“神奇的写法”，如：

```js
AddTag.showModal({
    data: ['111'],
    onSuccess: (value) => {
      console.log(value);
      // alert(value);
    },
  });
payload.onSuccess!([form.getFieldsValue()]);
```

onSuccess 是一个函数，我们使用函数的方式进行使用，这里的一个细节是在调用函数的括号前添加了一个 **!** ，经过同事的讲解，得知这是 ts 的写法。解析如下：

payload 这个参数有 onSuccess 属性，其可以是函数类型，也可以不传，所以我们直接执行的时候 ts 会警告，有可能没有传这个参数，这是编辑器防止报错的友好提示，但是写代码的是我们自己，我们自己肯定知道有没有传这个函数，所以就可以加这个 **!** 相当于告诉编辑器我们一定有传这个值，非常好用！！

## antd

#### Form 表单使用细节

antd 的 Form 表单和 Vue 相关的组件的 Form 表单的差别还是非常之大的，如：

```js
import { Form, Input } from 'antd'
import { memo } from 'react'

const initMsg = {
	username: 'Jimmy',
}
export default memo(() => {
	return (
		<Form name="basic" initialValues={initMsg} onFinish={() => {}}>
			<Form.Item
				label="Username"
				name="username"
				rules={[{ required: true, message: 'Please input your username!' }]}
			>
				<Input />
			</Form.Item>
		</Form>
	)
})
```

Form.Item 中如果只放了一个表单组件如 Input，则 Input 会自动的双向绑定至 Form.Item 中的 name 所对应的属性值！

- 有且仅有 Form.Item 中只有表单组件时才会生效，否则都是不绑定成功

如果想要实现如 form 表单之后添加文字，需要嵌套 Form.Item，如：

```js
import { Form, Input, Space } from 'antd'
import { memo } from 'react'

const initMsg = {
	username: 'Jimmy',
}
export default memo(() => {
	return (
		<Form name="basic" initialValues={initMsg} onFinish={() => {}}>
			<Form.Item
				label="Username"
				name="username"
				rules={[{ required: true, message: 'Please input your username!' }]}
			>
				<Space>
					<Form.Item name="username">
						<input />
					</Form.Item>
					<span style={{ marginBottom: 22, display: 'block' }}>哈哈哈</span>
				</Space>
			</Form.Item>
		</Form>
	)
})
```

## git

#### 需求开发流程

:::demo

```vue
<template>
	<div class="demo">
		<iframe
			src="//player.bilibili.com/player.html?aid=424243018&bvid=BV1B3411L7dx&cid=511907375&page=1"
			scrolling="no"
			border="0"
			frameborder="no"
			framespacing="0"
			allowfullscreen="true"
		>
		</iframe>
	</div>
</template>
<style>
.demo > iframe {
	width: 100%;
	height: 450px;
}
</style>
```

:::

当接到一个需求，如：优惠券管理这个后端。可以按照此流程进行下去。

- 先本地创建一个分支，如：feature/bugcoupouns，并在这个项目上进行基本的需求开发

  - 开发过程中如果完成一个功能点就 commit 一次，不要全部完成了之后再一次 commit。
  - 多次 commit 记录可以方便回退到以前某个功能点前的代码
  - 直到开发完成最后一个 commit 提交

- 切换到 test 分支，拉取最新的 test 分支的代码。

- 使用 `cherry-pick` 命令将历史的 commit 记录提交到 同步到 test 上

  ```sh
  # 只有一个commit
  git cherry-pick e60d8d20268ad60f3268aa58d8f2a75767d6ccb7

  # 多个commit记录
  git cherry-pick e60d8d20268ad60f3268aa58d8f2a75767d6ccb7^...c6e9a4e4bb80dac7bffa5c084fa86b25b6bbc332
  ```

- 使用 `git push` 将本地代码推送到远端

- 切换回开发分支

- 将开发分支同步推送到远端 `git push -u origin feature/coupons`

  远端也会有一个 feature/bugcoupons 分支，也方便其他人看对代码改动了什么东西.

#### 关于版本回退

:::demo

```vue
<template>
	<div class="demo">
		<iframe
			src="//player.bilibili.com/player.html?aid=211730082&bvid=BV1qa411C7Pc&cid=514121234&page=1"
			scrolling="no"
			border="0"
			frameborder="no"
			framespacing="0"
			allowfullscreen="true"
		>
		</iframe>
	</div>
</template>
<style>
.demo > iframe {
	width: 100%;
	height: 450px;
}
</style>
```

:::

版本回退是 git 最棒的功能之一，git 给了我们一个可以犯错的机会，当我们不小心改错代码无法通过撤销操作回去的时候，这时候使用 git 的版本回退的特性，就可以非常好的让我们回到”**犯错前**“（前提是我们做好相对应的版本提交），以下是几个最重要的命令。

- 查看提交记录的日志

  ```sh
  git log
  ```

  会返回一系列非常长的哈希值，哈希值是版本回退的关键！ 也可以配合`git cherry-pick`使用

  ![image-20220221221948225](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220221221948225.png)

- 查看历史的 git 操作

  ```sh
  git reflog
  ```

  返回一些对版本的操作，不会包含 `git add`、`git status`的记录，所以非常的清晰！

  ![image-20220221222239169](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220221222239169.png)

- 回退历史版本

  ```sh
  # git git reset --hard + 哈希值
   git reset --hard 225a4b4 # 回退到 225a4b4 这个版本
  ```

  命令非常简单，只需要传递一次版本的哈希值即可快速在版本之间切换

总结下来比较关键的就是像同事说的，既然用了 git 就要充分的发挥 git 的作用，在做完一个小功能点的时候就打一次 commit，这是一个好习惯！
