# 知识点记录

> React+Ts+antd技术栈

## React

### React.memo

高阶组件，如果组件在相同的props下渲染出相同的结果，使用这个方法处理之后直接复用最近一次的渲染的结果，是一个性能优化的处理方式。

一般子组件最好都是需要使用这个方法处理一下，避免子组件不必要的渲染。

- memo只检查props变成，如果是useState之类的变更，它仍会重新渲染

~~~react
function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, nextProps) {
  /*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */
}
export default React.memo(MyComponent, areEqual);
~~~

#### useModule

UmiJs的一个hook，提供消费Model能力，相当于是处理全局状态，跨组件通信方式。

useModule有两个参数，namespace和updater。

- `namespace` - 就是 hooks model 文件的文件名，如上面例子里的 `useAuthModel`
- `updater` - 可选参数。在 hooks model 返回多个状态，但使用组件仅引用了其中部分状态，并且希望仅在这几个状态更新时 rerender 时使用（性能相关）。

~~~react
import { useModel } from 'umi';

export default () => {
  const { user, fetchUser } = useModel('user', model => ({ user: model.user, fetchUser: model.fetchUser }));
  return <>hello</>
};
~~~

**在项目中使用案例**

~~~react
// models文件夹中创建一个dzInfo.ts
import { useState } from 'react';

export default function useDzInfo() {
  const [info, setInfo] = useState({ name: 'Jimmy', love: 'xuexue' });
  return {
    ...info,
    setInfo,
  };
}

// 在其他的任意组件内部使用
import { useModel, memo } from 'umi';
export default memo(()=>{
  const { name, love, setInfo } = useModel('dzInfo')
  return (
    <div>hello world</div>
  )
})
~~~

## TypeScript

#### 强制类型转换

umi提供了一个`useLocation`钩子，再钩子可以返回路由对象信息，其中就有query查询参信息，但是在项目中直接写会报错提示找不到query参数。但是实际上我们可以获取到这个参数，为了解决这个问题可以使用强制类型转换，先转成 unkonow 类型，再转成我们想要的类型。

```react
import { memo, useState } from 'react';
import { useLocation, Location } from 'umi';

type dz = {
  query:{
    cardId:number
  }
}

export default memo(()=>{
  const { query } = useLocation() // ts类型报错
  // 解决方式1（不太好） 只有query 其他的属性不能访问了 如 pathname
  const { query } = useLocation() as unknow as {
    query:{
      cardId:number
    }
  }
  // 解决方式2（推荐） location 的其他属性 如 pathname 仍然可以正常访问
  const { query } = useLocation() as Location & dz
})
```

- & 符号在ts中表示类型的联合

  Location & dz 等于在Location类型的基础上加上dz这个类型

## antd

#### Form表单使用细节

antd的Form表单和Vue相关的组件的Form表单的差别还是非常之大的，如：

~~~react
import { Form, Input } from 'antd';
import { memo } from 'react';

const initMsg = {
  username:'Jimmy'
}
export default memo(()=>{
  return (
    <Form
    	name="basic"
      initialValues={initMsg}
      onFinish={()=>{}}
    >
    	<Form.Item
        label="Username"
        name="username"
        rules={[{ required: true, message: 'Please input your username!' }]}
      >
        <Input />
      </Form.Item>
    </Form>
  )
})
~~~

Form.Item中如果只放了一个表单组件如Input，则Input会自动的双向绑定至Form.Item中的name所对应的属性值！

- 有且仅有Form.Item中只有表单组件时才会生效，否则都是不绑定成功

如果想要实现如form表单之后添加文字，需要嵌套Form.Item，如：

~~~react
import { Form, Input, Space } from 'antd';
import { memo } from 'react';

const initMsg = {
  username:'Jimmy'
}
export default memo(()=>{
  return (
    <Form
    	name="basic"
      initialValues={initMsg}
      onFinish={()=>{}}
    >
    	<Form.Item
        label="Username"
        name="username"
        rules={[{ required: true, message: 'Please input your username!' }]}
      >
        <Space>
          <Form.Item name="username">
            <input />
          </Form.Item>
          <span style={{ marginBottom: 22, display: 'block' }}>哈哈哈</span>
        </Space>
      </Form.Item>
    </Form>
  )
})
~~~

