# 面试集合

![image-20211229234032345](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20211229234032345.png)

正如大圣老师的面试学习法，让我收获颇丰。确实是给了自己耻辱感，让知道了自己水平大概在什么段位，确实是该学习了！

## 一轮-骄兵必败

耻辱的我熬夜写下了这篇文章。😒😒😒😒😒😒

一个前端大牛朋友，找他准备了一些面试题给我做了一次模拟面试，本以为应该不会太难，所以我压根没有做一点的复习。反而觉得这就是个模拟不用太在意，不会难到哪里去我应该大部分都会。

正所谓骄兵必败！总结下来还是因为自己确实没有花时间去准备，导致自己看待面试的态度出现了问题。狠狠的打了自己的脸。

害~该学习了！

### 工作中遇到的难点，如何解决？

我：项目中遇到的难点其实也有蛮多的，只不过大部分的问题都是可以通过查看文档来进行解决的，之前有遇到过小程序处理并发请求的问题，后面是通过调研，使用一个库，实现将请求挂起，逐个进行请求。

第一个问题真的太重要了，虽然现在写的就那么几十个字，但是我的表达....一言难尽，过程中咿咿呀呀的含糊不清的讲了好久。以致于后面的问题让我感觉可能不会过，状态太差。所以第一个问题一定要回答好！。

### 说出 ES6 新增的数组的方法？

我：按说这种题目应该是送分题的，可是没有错，我居然翻车了，我说的是`map`、`reduce`、`concat`、`filter`。

面试官：没有一个是 ES6 的

我.......

正确答案：

实例方法：`find`、`findIndex`、`includes`、`once`、`some`

原型方法：`Array.from()`、`Array.of()`、`Array.entries()`,`Array.keys()`、`Array.values()`

总结：看到答案的我吐血了，这些方法真的每一个我都会用也都能说出来分别的不同点，只是让我说一个个说出来我卡壳了....对不起看了红宝书和犀牛书。

### 从性能考虑，数组插入元素从头插入性能高还是从尾插入性能高

听到这题的时候我是一脸懵逼的，真的这是啥题，我真的不知道啊

我：数组插入元素应该是从头插入性能更低吧（回答的非常的不自信，含糊其辞，就算蒙对了面试官肯定也不会有什么好感的）

正确答案：

在数组的起始位置插入和删除元素的性能是更低的，因为在内存中，数组是一块连续的区域。

- 插入数据时，待插入位置的的元素和它后面的所有元素都需要向后搬移
- 删除数据时，待删除位置后面的所有元素都需要向前搬移

所以这题考察的还是基本常识，要知道数组在计算机内存中存储的方式。

### 对象深拷贝方法？

我：通过类似于`{...obj}`解构,只答出了这一个，如果是数组我可能还能憋出一个`Array.from()`

正确答案：

ES6 结构、`Object.assign({} ,obj1)`Object 原型方法、`JSON.parse(JSON.stringify(obj))`JSON 方法

### 闭包是什么，你认为的闭包最大的作用是什么？

我：因为 JS 采用的是词法作用域，也就是说只有一个函数或者变量的作用域取决于你在书写代码之后，而不是函数在哪里执行，当函数执行的作用域和函数书写时的作用域不在同一个地方的时候闭包就产生了。

我以为我说到这里就可以了，面试官继续问你觉得闭包最大的作用是什么？

我：...沉默了蛮久的，我说在我的想法中 JS 闭包最大作用是成就异步特性，因为所有的回调函数本质上都是闭包。

正确答案：

闭包的作用：

- 变量长期驻扎在内存当中（一般函数执行完毕，变量和参数会被销毁）
- 避免全局变量的污染

### Vue 响应式原理

我是看过源码的，并且也是写过整个迷你响应式代码的，我的这个问题回答的跟个屎一样。

我：Vue3 是通过 Proxy 这个代理机制实现响应式，每当对象触发`[[GET]]` 、`[[PUT]]`操作的时候都可以对数据进行拦截进行数据的更改

面试官：能说说具体`[[GET]]` 、`[[PUT]]`Vue3 是怎么做的吗

我：Vue3 主要是通过代码，来实现拦截，当`[[GET]]`的时候会触发一个依赖收集的过程，这个收集的时候就会触发一个个的副作用更新函数，当通过`[[PUT]]`修改的时候就会找到一个依赖收集关系，去触发的依赖的一个个副作用函数。

我的回答问题的能力真的很差，感觉有点像是挤牙膏一样，按道理这个应该是我一口气说下来的，谁都知道是通过`Proxy`，但是应该要自己把所有的东西都说出来，而不是需要别人提醒你返回推敲。

### 除了 Vue 的这种观察监听的设计模式，你还知道什么设计模式

之前刷掘金有专门刷到一篇 JS 涉及模式文章，里面讲了很多，但是还是老毛病看了就忘。

我：涉及模式我知道有蛮多的，但是除了 Vue 的这个我目前能说出来的可能只有一个 **单例模式**、

面试官：那你说下单例模式是如何实现的，你在什么时候有用到过

我：在写自己毕设的时候那时候用 node 搭建后台服务器 API 时候，增删改查接口都涉及到连接数据库，那么连接数据库这个操作就需要使用单例模式，因为连接数据库只需要一次。实现单例模式可以简单的使用一个类，然后写一个类的静态方法，通过静态方法和静态属性实现单例

面试官：除了用类还有没有用其他更简单的方法

我：除了用类我可能还会用函数吧，因为类本质上是函数的语法糖。

**正确答案：**

js 设计模式有

- 单例模式
- 策略模式
- 代理模式
- 中介者模式
- 装饰者模式

除了单例和策略代理有听过，别的都没有听过，好像有专本一本书写 js 设计模式的，有空一定要看下

实现单例模式的方法：

查了一下居然有 6 种：

- instanceof

  ```js
  function User() {
    if (!(this instanceof User)) {
      return;
    }
    if (!User._instance) {
      this.name = "无名";
      User._instance = this;
    }
    return User._instance;
  }

  const u1 = new User();
  const u2 = new User();

  console.log(u1 === u2); // true
  ```

- 在函数上直接添加方法属性调用生成实例

  ```js
  function User() {
    this.name = "无名";
  }
  User.getInstance = function () {
    if (!User._instance) {
      User._instance = new User();
    }
    return User._instance;
  };

  const u1 = User.getInstance();
  const u2 = User.getInstance();

  console.log(u1 === u2);
  ```

- 使用闭包，改进方式 2

  ```js
  function User() {
    this.name = "无名";
  }
  User.getInstance = (function () {
    var instance;
    return function () {
      if (!instance) {
        instance = new User();
      }
      return instance;
    };
  })();

  const u1 = User.getInstance();
  const u2 = User.getInstance();

  console.log(u1 === u2);
  ```

- 使用包装对象结合闭包的形式实现

  ```js
  const User = (function () {
    function _user() {
      this.name = "xm";
    }
    return function () {
      if (!_user.instance) {
        _user.instance = new _user();
      }
      return _user.instance;
    };
  })();

  const u1 = new User();
  const u2 = new User();

  console.log(u1 === u2); // true
  ```

- 在构造函数中利用 new.target 判断是否使用 new 关键字

  ```js
  class User {
    constructor() {
      if (new.target !== User) {
        return;
      }
      if (!User._instance) {
        this.name = "xm";
        User._instance = this;
      }
      return User._instance;
    }
  }

  const u1 = new User();
  const u2 = new User();
  console.log(u1 === u2);
  ```

- 使用 static 静态方法

  ```js
  class User {
    constructor() {
      this.name = "xm";
    }
    static getInstance() {
      if (!User._instance) {
        User._instance = new User();
      }
      return User._instance;
    }
  }
  
  const u1 = User.getInstance();
  const u2 = User.getInstance();
  
  console.log(u1 === u2);
  ```

### 数组和链表的区别

我听到这个问题想的是，天哪这个问题我应该要怎么回答，好难，不会答。

我：链表的数据结构是存储值和下一个值的指针，而数组是维护一个索引下标，硬要说区别的话就是遍历的区别，链表没有办法从中间取值，要找到一个值就必须先获取这个值的前一个值。

正确答案：

- 在内存中，数组是一块连续的区域
- 在数组起始位置处，插入数据和删除数据效率低。
- 查找速度快，时间复杂度为 O(1)
- 链表在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续
- 查找数据时效率低,时间复杂度为 O(N)：因为链表的空间是分散的，所以不具有随机访问性，如要需要访问某个位置的数据，需要从第一个数据开始找起，依次往后遍历，直到找到待查询的位置，故可能在查找某个元素时，时间复杂度达到 O(N)
- 任意位置插入元素和删除元素效率较高，时间复杂度为 O(1)，因为只需要改变指针的指向即可
- 链表的空间是从堆中分配的，数组的空间是从栈分配的

### 插入排序、选择排序、冒泡排序的时间复杂度

我：这三个排序我都会写，但是具体的孰优孰劣我一时没有办法说出来，只知道它们都是二层循环，冒泡排序的时间复杂度应该是最高的吧，每次都需要亮亮比对

我这个答的就非常的不好，首先是回答问题不自信，然后我确实也没有去刻意背这个，不过算法我是真的都写过这三种排序

**冒泡排序**

冒泡算法是最基础的一个排序算法

两层循环，每次两两进行比对。

```js
// 冒泡排序
function bubbleSort(arr) {
  let temp;
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[i]) {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
```

**选择排序**

第一轮 从数组第 0 个元素开始遍历 在遍历的过程中如果找到最小的值 就将这个最小的值 和数组的第 0 个值进行替换

第二轮 从数组第 1 个元素开始遍历 在遍历的过程中如果找到最小的值 就将这个最小的值 和数组的第 1 个值进行替换

....

最终数组循环遍历结束之后 数组也就拍好了

需要使用两层循环 时间复杂度为 ON2

选择排序适用于数组量小的情况下 好处是操作的一直都是同一个数组 时间换空间的方式

```js
function selectSort(arr) {
  let minIndex;
  for (let i = 0; i < arr.length; i++) {
    minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }

  return arr;
}
```

**插入排序**

这个排序的场景是十分的像我们打扑克的时候的场景，

抽一张牌时（current） 会一个个的和前面的牌进行比较

直到找打比这个牌小的地方（preIndex） 插入进去 后面的全部往后挪动一位

这个排序也比较好理解 时间复杂度也是 ON2

```js
function insertSort(arr) {
  let length = arr.length;
  let preIndex, current;
  for (let i = 1; i < length; i++) {
    preIndex = i - 1; // 记录前一个数的索引
    current = arr[i]; // 记录比较的这个值
    while (preIndex >= 0 && arr[preIndex] > current) {
      // 在这个循环下 如果前一个数比当前这个数大 则后一个将前一个数覆盖
      arr[preIndex + 1] = arr[preIndex];
      preIndex--;
    }
    // 当循环结束 说明找到了需要替换的位置 将这个位置的值替换成最初存的那个current即可
    arr[preIndex + 1] = current;
  }
  return arr;
}
```

总结：

- 三者的时间复杂度都是 O(n2)

- 冒牌排序的效率最低
- 当数组量小的时候，应该优先使用选择排序

### 二叉树左右子树呼唤

我：不好意思这个我没有写过这个，不过这个问题应该也是和二叉树的遍历差不多可以用递归的方式进行解决的。

我觉得这个问题我不会应该坦诚的说我不会，但是我又间接的告诉面试官我会二叉树的遍历，我不知道这样的回答问题的模式是否是不好的，有点不懂装懂的感觉。

### 不用递归，使用循环的方式完成二叉树的先序遍历

可能因为我说了递归解决二叉树的遍历，所以面试官特意问我通过循环遍历......，万马奔腾。

我：面试官不好意思，循环的方式我没有写过，我直接解决二叉树遍历问题都是通过递归的方式来进行解决的。

**递归二叉树先序遍历**

```js
var preorderTraversal = function (root) {
  let res = [];
  const inOrder = (root) => {
    if (!root) {
      return;
    }
    res.push(root.val); // 先存
    inOrder(root.left); // 进入左节点
    inOrder(root.right); // 进入右节点
  };
  inOrder(root);
  return res;
};
```

**循环二叉树先序遍历**

这个我确实不会，有空再刷刷题吧研究一下。

### 总结

这一场面试是让我感觉备受耻辱，问题就没有几个算是答上来的，就算过了就这个面试情况也失去和 HR 讨价还价的资本了。除了算法的问题其他的问题问的真的不难，我居然还是翻车了，亏自己看书看了很多遍还是不能应付下来。也是跟自己自负有点关系了，程序员不能太气盛，骄兵必败。

- 磨练自己的嘴皮子，软技能真的太重要了，表达能力真的是差到不行！
- 认真对待面试，就算是模拟，也应该跟真的面试一样，即使准备和复习基础知识。
- 算法题还是得继续坚持下去，这回问算法不算一点都没有答出来，但是总体还是差！

## 二轮-其实我都不会

简单的寒暄，直接进入主题 😒😒😒

### 0 == null 答案是 true 还是 false （两个等号）

我：应该不等吧（含糊的回答）
面试官：到底相等还是不相等？
我：应该相等，因为他们都会转成 false 进行比较。

**正确答案**

其实二者不相等。

很显然这题是面试官特意挖坑，在说题目的时候特意跟我说两个等号，就想着能快速的说出来，我还是入坑了......

### 0.1+0.2 会等于0.3吗

我：不等于，会等于0.300000000...04。

面试官：为什么？

我：呃...因为Number类型底层其实是用二进制进行表示的，所以会有精度问题

面试官：那怎么解决？

我：不好意思我没有试过，如果我处理我会手动封装一个`add`方法，然后单独判断0.1+0.2的情况返回0.3

**正确答案**

Number类型本质上是二进制浮点数，表示整数的时候一点问题都没有，而表示小数的时候就会有精度的问题。如：

- 二进制表示整数采用的是： **除2取余法**
- 二进制表示小数采用的是： **乘2取整法**

```js
// toString(2)表示转成2进制  toString(10)表示转成10进制
Number(0.2).toString(2) // 将0.2转为二进制 '0.001100110011001100110011001100110011001100110011001101'
```

为什么是这个数字呢？其实使用的是 **乘2取整法**

```
0.2 * 2 = 0.4 取整数部分0 小数部分0.4
0.4 * 2 = 0.8 取整数部分0 小数部分0.8
0.8 * 2 = 1.6 取整数部分1 小数部分0.6
0.6 * 2 = 1.2 取整数部分1 小数部分0.2
0.2 * 2 = 0.4 取整数部分0 小数部分0.4
0.4 * 2 = 0.8 取整数部分0 小数部分0.8
0.8 * 2 = 1.6 取整数部分1 小数部分0.6
.....
0.0011001.... 无限循环
所以本质上取小数时有时候是取得不是精确数是近似数，近似数相加就会出现不精准的时候。
```

### 一个函数先执行`bind()`后执行`call()`最终this指向的是`bind`绑定的对象还是`call`绑定的对象

在还没有听到具体题目前，听他说函数call、apply、bind我以为我稳了，这个太简单了我都会，结果没想到并没有单独的问我，而是组合起来问我......

我：这个我没有试过，不过应该是`call()`应该`call()`是后面执行的。

面试官：是`bind()`，你下去了以后可以试验一下

之后我看了 **《JavaScript忍者秘籍》** 发现其中在函数中有一段话，一旦一个函数通过`bind()`确定了this指向之后就无法再进行修改了。所以这个考的真的蛮....细节的，真的会有人先bind再call这样用嘛。

### 一个函数，连续的`bind()`了三次，那最终this指向的是最初的那个还是最后的那个？

我：应该是最初的那个。

面试官：为什么？

我：因为上一题我答错了，感觉`bind()`应该是效果更强的，不能被再次覆盖。

面试官：是的，建议下去之后手动的实验一下。

一旦一个函数通过`bind()`确定了this指向之后就无法再进行修改了。

### 给你10秒钟，看看你一口气能说出多少数组的方法

我：map、filter、forEach、some、find、findIndex、reduce、sort、concat、includes、keys、values、entrys

面试官：还有吗？

我：没有了。

面试官：少了，还有push、pop、reserve、indexOf等等，这题要考的其实是看你日常编码时的积累，写的多你就能临时说的多。

我又傻了，居然连数组最基本的push、pop之类的都没有说出来。可能会让面试官觉得我是个背题的，连最经常用的都不知道。

### 你知道的js类型转换有什么方法？比如`String()`

我：Number、Boolean、!!、+、!

好像有的并不止这些，还有`toString()`

### 一个构造函数在new的过程中都做了什么？

我：先是创建一个空对象，然后将构造函数中this有绑定的东西都绑定到这个空对象上，并将这个空对象的`[[proto]]`指向构造函数的`prototype`

其实这题我答的不好，标准答案应该是：

- 先创建一个空对象
- 将这个空对象作为this传入构造函数中
- 将绑定之后的结果作为`new` 操作符的结果进行返回

### 你知道对象的`construcotr`属性吗，代表的是什么？

我：对象的`constructor`一般情况下代表的是这个对象是由哪个构造函数所实例化出来的，但是这个属性是不可靠的，是可以被显示的修改的。

demo：

```js
function User(){}
function CopyUser(){}

let jimmy = new User()
jimmy.constructor = CopyUser
console.log(jimmy.constructor) // CopyUser
```

看！通过以上的例子，一个对象的`constructor`居然能被我们手动的给修改！所以对象的`constructor`是不可靠的，并不能代码这个对象一定是根据这个构造函数所实例化出来的。

### setTimeOut(()=>{},0)能立即执行吗

我：不能，因为解析器在解析代码时，遇到`setTimeOut`会将执行的内容放入任务队列，等到主线程的代码执行结束之后才会轮询异步队列，所以就算时写0也不会立刻执行。

### 如何让script标签不阻塞文档的解析

我：可以通过让script标签加上`async`和`defer`属性，可以让script标签异步的进行加载。

面试官：那二者有什么区别？

我：`async`和`defer`都是后台下载，区别在于，当`async script`后台下载好之后会立即停止文档的解析，转而去解析这个script，而`defer`是会在整个文档解析完成之后了，再去解析这个`defer script`

这题考的就是`async script` 和`defer script` 异步脚本的知识。

### 有什么办法能让setTimeOut立刻执行

我：不好意思我没有处理过，不会，如果有这种需求通过手写回调函数？

面试官：这题其实想考你对js的理解，js为什么有异步队列呢？因为是单线程，不异步处理会阻塞，所以这题思路应该是往线程的方向处理，js单线程那变成多线程不就可以了，现在不是有`webWorker`新API可以再开一个线程吗，所以是想考你有没有熟悉一些新的API

我傻了，webWorker其实看书啥的有看到过，也知道主要是处理什么问题的，但是确实是自己没有用过，所以很难答的出来，也不知道面试官其实要考我的是这个。

### 结束扎心时刻

面试官：好了今天就问到这里吧，我大概知道了，你的JS基础还是相对薄弱的，我这都还没有问你框架源码呢。

我：不好意思我有点紧张，有些问题没有答好。

害！我这一年看了 红宝书、犀牛书、小黄书，结果居然被说js还是太薄弱了.....，雷霆一击一般，不过总结下来我也知道了我的薄弱项，看书喜欢跳过，遇到看不懂的也是直接跳过，这个习惯其实不好，所以下定决心，这回的 **《JavaScript》忍者秘籍** 我一定耐心的看下去，尽量不跳过。

不过确实，全问JS我都没有答好，还没问框架源码和算法呢，惊了。

还有一点是现在面试公司基本都问设计模式，所以安排了一本 **《前端架构-从入门到微前端》**这本也是 **程序员鱼皮** 推荐的一本架构和设计模式的书籍，忍者书看完就看。

最后，我以为我必挂，感谢领导，结果居然过了......

