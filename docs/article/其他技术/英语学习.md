# 学习英语，是不是变相的提升自己的编程能力呢？

果然后悔自己当初没有认真学习，再次体会到了不好好学习所带来的痛点。

![image-20220511222149084](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220511222149084.png)

我的目标就是提升自己的英语阅读能力（先不涉及口语），至少先做到不会被英文文档劝退！

## 身边有几个有趣的同事

一个大四英语专业的女同事，技术和能力都挺强的（比我大四的时候要强也要厉害，无论的编码能力还是薪资），坐我旁边，发现她经常看英文的文档，虽然这个和技术没有必然的联系，但就这一点已经购全方位吊打我了。

另一个自称没有通过英语四级的同事，印象中也是一个勇于看英文文档的勇者（对我来说是一个勇者，因为我基本看到英语文档就会被劝退），一次偶然机会我和他一起看一篇技术类文章，我不会的地方他都能很好的翻译出来，因为这个也令我对他再次刮目想看！

甚至还有技术很强的同事因为英语不好错过了一些更好的工作机会！

![image-20220511221333384](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220511221333384.png)

## 我打算如何学习呢？

诚然，毕业之后的我不知道应该如何学习英语了，背单词？看长难句？好像都不太行。

就完整的看一篇英文文档吧！我选择的是 Vue3 的官网：[传送门](https://vuejs.org/) ，原因有下：

- Vue3 是新技术，看官网除了学习英文以外，还能学习到一些其作者想表达的一些开发思想
- Vue3 有中文文档，在实在看不下去的时候，难以理解的时候，还有 **参开答案**

再搭配上翻译插件，目前看来是一个还蛮不错的方式！

## 阅读记录

- [x] 首页

- [x] Introduction

  介绍了什么是Vue，其中比较重要的两个核心特性，对渐进式框架、单文件组件、做出解释，同时介绍了两种API风格，并做出两种风格的对比以及简单的建议。最后是学习路径的推荐。

- [x] Quick Start

  快速开始的内容，推荐了Vite这个更快更轻的构建工具，使用构建工具构建一个新项目，以及我们可以不使用构建工具的情况下运行Vue3的代码，提供了一些代码案例，其中使用到了一些比较新的API，如`type = importmap`，如下：

  ```html
  <script type="importmap">
    {
      "imports": {
        "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
      }
    }
  </script>
  
  <div id="app">{{ message }}</div>
  
  <script type="module">
    import { createApp } from 'vue'
  
    createApp({
      data() {
        return {
          message: 'Hello Vue!'
        }
      }
    }).mount('#app')
  </script>
  ```

  这个对于我来说是个新东西，过去我只知道使用`type = import`让浏览器直接使用ESM来进行解析一些模块化的语法，现在才知道可以直接这样写，支持模块化的导入一些线上的库，就有点类似于`package.json`的作用了。

  只是这个语法和vue3一样有兼容性，只有现代的浏览器才能使用。

- [x] Creating an Application

  可以通过`createApp()`方法创建一个应用实例，同时要注意需要有一个根组件，其他的组件都基于这个根组件之上实现，

  `mount()`方法挂载之前整个应用实例都不会进行渲染，最后是介绍了一些APP的配置项，如注册组件等，其中比较重要的也是之前不太清晰的是，app实例会暴露一个config对象，可以在这个config上做一个操作，如：全局的错误处理等等：

  ```js
  app.config.errorHandler = (err) => {
    /* handle error */
  }
  ```

  也可以在一个应用上使用多个实例（如果需要这么做的话）

  ```js
  const app1 = createApp({
    /* ... */
  })
  app1.mount('#container-1')
  
  const app2 = createApp({
    /* ... */
  })
  app2.mount('#container-2')
  ```

- [x] Template 语法

  介绍一些Template的语法以及Vue的一些指令，如：插值表达式、v-html、等等，语法和vue2一致，对我来说没有什么比较新奇的东西，就不详细记录了。

- [x] Reactivity Fundamentals

  响应式系统是通过`Proxy API`实现的，和Vue2不同的地方在于，一些自定义的值是不会被设为响应式的，确保始终将响应式状态作为 this 的属性访问：

  ```js
  export default {
    data() {
      return {
        someObject: {}
      }
    },
    mounted() {
      const newObject = {}
      this.someObject = newObject
  
      console.log(newObject === this.someObject) // false
    }
  }
  
  // newObject 并不会成为一个响应式对象
  ```

  DOM更新的时机实际上并不是同步更新的，而是每次state更改都会统一收集一些变化，再在**next tick**时机进行更新（这么做可能是为了达到性能最优避免太多次的render吧，我猜的），**next tick**我还不是很清晰，之后的内容更新到会详细的记录。

  默认响应式系统都是会支持深层次的对象的，为了性能优化我们可以使用`shallowReactive()`只给根层次的对象属性绑定上响应式，这个也是一个性能优化的点。

  最后是如何使用一个安全的**自带状态的函数**的函数，如：防抖、节流这种函数本身是自带状态的，项目中经常使用`lodash`工具库，如果直接使用会触发状态碰撞问题可能达不到效果，这时候可以将函数在实例上绑定一次再使用就不会有问题：

  ```js
  // 可能会有问题， debounce 本身就有状态
  import { debounce } from 'lodash-es'
  
  export default {
    methods: {
      // Debouncing with Lodash
      click: debounce(function () {
        // ... respond to click ...
      }, 500)
    }
  }
  
  // 解决方法 -- 状态统一
  export default {
    created() {
      // each instance now has its own copy of debounced handler
      this.debouncedClick = _.debounce(this.click, 500)
    },
    unmounted() {
      // also a good idea to cancel the timer
      // when the component is removed
      this.debouncedClick.cancel()
    },
    methods: {
      click() {
        // ... respond to click ...
      }
    }
  }
  ```

  
