---
head:
  - - meta
    - name: description
      content: 学习英语，是不是变相的提升自己的编程能力呢？
  - - meta
    - name: keywords
      content: 学习英语，是不是变相的提升自己的编程能力呢？

  - - script
    - src: https://vitepress-source.oss-cn-beijing.aliyuncs.com/statistics.js
---

# 学习英语，是不是变相的提升自己的编程能力呢？

果然后悔自己当初没有认真学习，再次体会到了不好好学习所带来的痛点。

![image-20220511222149084](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220511222149084.png)

我的目标就是提升自己的英语阅读能力（先不涉及口语），至少先做到不会被英文文档劝退！

## 身边有几个有趣的同事

一个大四英语专业的女同事，技术和能力都挺强的（比我大四的时候要强也要厉害，无论的编码能力还是薪资），坐我旁边，发现她经常看英文的文档，虽然这个和技术没有必然的联系，但就这一点已经购全方位吊打我了。

另一个自称没有通过英语四级的同事，印象中也是一个勇于看英文文档的勇者（对我来说是一个勇者，因为我基本看到英语文档就会被劝退），一次偶然机会我和他一起看一篇技术类文章，我不会的地方他都能很好的翻译出来，因为这个也令我对他再次刮目想看！

甚至还有技术很强的同事因为英语不好错过了一些更好的工作机会！

![image-20220511221333384](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220511221333384.png)

## 我打算如何学习呢？

诚然，毕业之后的我不知道应该如何学习英语了，背单词？看长难句？好像都不太行。

就完整的看一篇英文文档吧！我选择的是 Vue3 的官网：[传送门](https://vuejs.org/) ，原因有下：

- Vue3 是新技术，看官网除了学习英文以外，还能学习到一些其作者想表达的一些开发思想
- Vue3 有中文文档，在实在看不下去的时候，难以理解的时候，还有 **参考答案**

再搭配上翻译插件，目前看来是一个还蛮不错的方式！

## 阅读记录

- [x] 首页

- [x] Introduction

  介绍了什么是 Vue，其中比较重要的两个核心特性，对渐进式框架、单文件组件、做出解释，同时介绍了两种 API 风格，并做出两种风格的对比以及简单的建议。最后是学习路径的推荐。

- [x] Quick Start

  快速开始的内容，推荐了 Vite 这个更快更轻的构建工具，使用构建工具构建一个新项目，以及我们可以不使用构建工具的情况下运行 Vue3 的代码，提供了一些代码案例，其中使用到了一些比较新的 API，如`type = importmap`，如下：

  ```html
  <script type="importmap">
  	{
  		"imports": {
  			"vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
  		}
  	}
  </script>

  <div id="app">{{ message }}</div>

  <script type="module">
  	import { createApp } from 'vue'

  	createApp({
  		data() {
  			return {
  				message: 'Hello Vue!',
  			}
  		},
  	}).mount('#app')
  </script>
  ```

  这个对于我来说是个新东西，过去我只知道使用`type = import`让浏览器直接使用 ESM 来进行解析一些模块化的语法，现在才知道可以直接这样写，支持模块化的导入一些线上的库，就有点类似于`package.json`的作用了。

  只是这个语法和 vue3 一样有兼容性，只有现代的浏览器才能使用。

- [x] Creating an Application

  可以通过`createApp()`方法创建一个应用实例，同时要注意需要有一个根组件，其他的组件都基于这个根组件之上实现，

  `mount()`方法挂载之前整个应用实例都不会进行渲染，最后是介绍了一些 APP 的配置项，如注册组件等，其中比较重要的也是之前不太清晰的是，app 实例会暴露一个 config 对象，可以在这个 config 上做一个操作，如：全局的错误处理等等：

  ```js
  app.config.errorHandler = err => {
  	/* handle error */
  }
  ```

  也可以在一个应用上使用多个实例（如果需要这么做的话）

  ```js
  const app1 = createApp({
  	/* ... */
  })
  app1.mount('#container-1')

  const app2 = createApp({
  	/* ... */
  })
  app2.mount('#container-2')
  ```

- [x] Template 语法

  介绍一些 Template 的语法以及 Vue 的一些指令，如：插值表达式、v-html、等等，语法和 vue2 一致，对我来说没有什么比较新奇的东西，就不详细记录了。

- [x] Reactivity Fundamentals

  响应式系统是通过`Proxy API`实现的，和 Vue2 不同的地方在于，一些自定义的值是不会被设为响应式的，确保始终将响应式状态作为 this 的属性访问：

  ```js
  export default {
  	data() {
  		return {
  			someObject: {},
  		}
  	},
  	mounted() {
  		const newObject = {}
  		this.someObject = newObject

  		console.log(newObject === this.someObject) // false
  	},
  }

  // newObject 并不会成为一个响应式对象
  ```

  DOM 更新的时机实际上并不是同步更新的，而是每次 state 更改都会统一收集一些变化，再在**next tick**时机进行更新（这么做可能是为了达到性能最优避免太多次的 render 吧，我猜的），**next tick**我还不是很清晰，之后的内容更新到会详细的记录。

  默认响应式系统都是会支持深层次的对象的，为了性能优化我们可以使用`shallowReactive()`只给根层次的对象属性绑定上响应式，这个也是一个性能优化的点。

  最后是如何使用一个安全的**自带状态的函数**的函数，如：防抖、节流这种函数本身是自带状态的，项目中经常使用`lodash`工具库，如果直接使用会触发状态碰撞问题可能达不到效果，这时候可以将函数在实例上绑定一次再使用就不会有问题：

  ```js
  // 可能会有问题， debounce 本身就有状态
  import { debounce } from 'lodash-es'

  export default {
    methods: {
      // Debouncing with Lodash
      click: debounce(function () {
        // ... respond to click ...
      }, 500)
    }
  }

  // 解决方法 -- 状态统一
  export default {
    created() {
      // each instance now has its own copy of debounced handler
      this.debouncedClick = _.debounce(this.click, 500)
    },
    unmounted() {
      // also a good idea to cancel the timer
      // when the component is removed
      this.debouncedClick.cancel()
    },
    methods: {
      click() {
        // ... respond to click ...
      }
    }
  }
  ```

- [x] Computed Properties

  虽然支持在 Template 用插值表达式写一些表达式，但是如果太长其实不便于阅读，这里最好的是使用 `Computed` 计算属性来写，更便于阅读也更便于修改。

  使用`Method`也可以实现和`computed`一样的效果，但是我们应该要使用`Computed`，因为其会对数据做一层监听和缓存，只有当参与计算的属性变化时才会重新计算（render），而如果是`method`，则是会不管不顾，有数据变化就计算一次。所以这个也是性能优化的一个点。

  这块自己亲自写个小 demo 验证一下就很清晰了

- [x] Class and Style Bindings

  通过`v-bind`方式绑定`class`和`style`，大部分的知识点都比较熟悉，也有最新学习到的内容，就是直接给组件标签绑定类名，如果该的子节点只有一个元素（字根），那么子根会默认继承这个 class 的。

  ```vue
  <my-component class="baz boo">
  	<p class="foo bar">Hi!</p>
  </my-component>
  ```

  那么实际上会被渲染为：

  ```vue
  <p class="foo bar baz boo">Hi!</p>
  ```

  如果组件标签下有多个**一级**子元素，那么可以使用`$attrs.class`进行定向的接收：

  ```vue
  <my-component class="baz boo">
  	<p class="foo bar">Hi!</p>
    <h2 :class="$attrs.class">OK</h2>
  </my-component>
  ```

  那么实际上会被渲染为：

  ```vue
  <p class="foo bar">Hi!</p>
  <h2 class="baz boo">OK</h2>
  ```

- [x] Conditional Rendering

  `v-if`和`v-show`指令的介绍以及二者的区别，文档使用 v-if 时使用了一个更好的方式，就是使用`<template>`来作为根节点，过去我都是使用`div`标签作为根，这种其实更不好，无形之中多了一层结构，其实更不好。

  ```vue
  <template v-if="ok">
  	<h1>Title</h1>
  	<p>Paragraph 1</p>
  	<p>Paragraph 2</p>
  </template>
  ```

  这一块的最后给出了一个提示，也是一道经典的 vue 面试题，`v-if`不能和`v-show`一起使用。文档给出的答案：

  > When `v-if` and `v-for` are both used on the same element, `v-if` will be evaluated first.

  那就是`v-if`如果和`v-show`一起使用的话，会执行`v-if`

- [x] List Render

  v-for 的内容经常在用，所以大部分知识点都知道，其中一个和 v-if 一样的是可以配合`Template`一起使用（如果不想造成过多的 div 嵌套的情况下）

  ```vue
  <ul>
    <template v-for="item in items">
      <li>{{ item.msg }}</li>
      <li class="divider" role="presentation"></li>
    </template>
  </ul>
  ```

  再次解释为什么`v-for`和`v-if`不能一起使用，看下面的例子就明白了：

  ```vue
  <li v-for="todo in todos" v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
  ```

  如果这样写，会报错 **todo is not defined**之类的错误，因为`v-if`有着更加高的优先级，所以一起出现时会先解析`v-if`中的条件语句，而这时候，todo 还没有被定义，就会产生报错。

- [x] Event Handler

  这块汲取到的新知识有时间事件修饰符：

  | 修饰符      | 作用                    |
  | ----------- | ----------------------- |
  | @click.once | 点击事件最多被触发 1 次 |

  键盘事件的修饰符：
  | 修饰符 | 作用 |
  | ---- | ---- |
  | @keyup.enter | 回车键被按下 |
  | @keyup.tab | tab 被按下 |
  | @keyup.delete | delete 被按下 |
  | @keyup.esc | esc 被按下 |
  | @keyup.space | 空格被按下 |
  | @keyup.up | 上按下 |
  | @keyup.down | 下键被按下 |
  | @keyup.left | 左键被按下 |
  | @keyup.right | 右键被按下 |

  过去不知道到这些指令，要实现的话还需要手动去判断键盘对应的案件码还是一个相对繁琐的过程，而现在 vue 已经帮我们封装置指令上，使用起来可以非常的优雅。

- [x] Form Input Bingings

  `v-model`的使用，可以在表单是实现数据双向绑定

  几个修饰符：

  | 修饰符  | 作用                                                   |
  | ------- | ------------------------------------------------------ |
  | .lazy   | 默认情况下是同步更改，可添加修饰符使其在事件之后再同步 |
  | .number | 自动转类型为 number                                    |
  | .trim   | 自动去除空白                                           |

- [x] Lifecycle Hooks

  ![](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoralifecycle.16e4c08e.png)

  一图胜前言，需要知道的是`setup`是在最早执行的，执行时机甚至早于`beforeCreate`

- [x] Wather

  在`Composition API`中，使用`watch`(从 vue 包中导入)监听 reactive 对象某个属性变化时很容易写错，我们监听的对象需要使用函数的形式在处理，如：

  ```vue
  // Incorrect use

  <script>
  const obj = reactive({ count: 0 })

  // this won't work because we are passing a number to watch()
  watch(obj.count, count => {
  	console.log(`count is: ${count}`)
  })
  </script>

  // correctly use

  <script>
  const obj = reactive({ count: 0 })

  // this won't work because we are passing a number to watch()
  watch(
  	() => obj.count,
  	count => {
  		console.log(`count is: ${count}`)
  	}
  )
  </script>
  ```

  `watch`默认是深度的`watch`，如果不想深度观察可以给其传第三个参数，如：

  ```vue
  <script>
  ;() => state.someObject,
  	(newValue, oldValue) => {
  		// Note: `newValue` will be equal to `oldValue` here
  		// *unless* state.someObject has been replaced
  	},
  	{ deep: false }
  </script>
  ```

- [x] Template Refs

  ref 绑定 DOM 的方法。

- [x] Components Basics

  大部分的用法已经很熟悉了，其中`Slot`是过去我再`Vue2`时期就不太会用的东西，这里大致的学习一下。

  ```vue
  <template>
  	<AlertBox> Something bad happened. </AlertBox>
  </template>
  ```

  ```vue
  <template>
  	<div class="alert-box">
  		<strong>This is an Error for Demo Purposes</strong>
  		<slot />
  	</div>
  </template>

  <style scoped>
  .alert-box {
  	/* ... */
  }
  </style>
  ```

  `AlertBox`组件内部只需要直接使用`<slot />`标签，就可以将原本`<AlertBox>children</AlertBox>`内部的`children`自动的代入进去。

  **动态组件**

  使用`<component :is="myComponent">`即可创建一个动态组件，而且还能配合神奇的`<KeepAlive>`组件实现强制缓存内容：

  ```vue
  <template>
    <KeepAlive>
      <component :is="MyComponent">
    </KeepAlive>
  </template>
  ```

- [x] Component Register

  我们可以全局注册组件也可以在需要使用的地方注册组件

  本地注册（局部注册）有着更好的`Tree shaking`支持，如果是全局注册的组件，即使我们并未使用，也任然会被打包入最后的代码包，所以使用全局组件时需要慎重。

  组件不支持继承（父组件注册的组件只能在父组件中使用，子组件不能使用）

  推荐使用驼峰命名法命名组件
  
- [x] Props

  组件props是单向数据流，默认情况下我们无法从子组件改变父组件的值，如果强制改变会给出警告，如果props是对象或者数组类型我们也能改变数组和对象，但是绝对不要这么做，之所以能改变是因为数组和对象本质上是引用类型

  props支持类型校验，大致的代码如下：

  ```js
  defineProps({
    // Basic type check
    //  (`null` and `undefined` values will allow any type)
    propA: Number,
    // Multiple possible types
    propB: [String, Number],
    // Required string
    propC: {
      type: String,
      required: true
    },
    // Number with a default value
    propD: {
      type: Number,
      default: 100
    },
    // Object with a default value
    propE: {
      type: Object,
      // Object or array defaults must be returned from
      // a factory function. The function receives the raw
      // props received by the component as the argument.
      default(rawProps) {
        return { message: 'hello' }
      }
    },
    // Custom validator function
    propF: {
      validator(value) {
        // The value must match one of these strings
        return ['success', 'warning', 'danger'].includes(value)
      }
    },
    // Function with a default value
    propG: {
      type: Function,
      // Unlike object or array default, this is not a factory function - this is a function to serve as a default value
      default() {
        return 'Default function'
      }
    }
  })
  ```

- [x] Component Events

  用法基本和vue2用法保持一致，我们可以使用`defineProps`定义自定义事件。

  简单定义：

  ```vue
  <script setup>
    const emit = defineEmits(['inFocus', 'submit'])
  </script>
  ```

  ts支持下的类型：

  ```vue
  <script setup lang="ts">
    const emit = defineEmits<{
      (e: 'change', id: number): void
      (e: 'update', value: string): void
    }>()
  </script>
  ```

  事件校验：

  ```vue
  <script setup>
    const emit = defineEmits({
      // No validation
      click: null,
  
      // Validate submit event
      submit: ({ email, password }) => {
        if (email && password) {
          return true
        } else {
          console.warn('Invalid submit event payload!')
          return false
        }
      }
    })
  
    function submitForm(email, password) {
      emit('submit', { email, password })
    }
  </script>
  ```

  学到了一个非常新的操作，就是使用`v-model`快速的双向设置`props`和`event`，实现组件级别的数据双向绑定：

  ```vue
  <MyComponent v-model:title="bookTitle" />
  
  <!-- MyComponent.vue -->
  <script setup>
  defineProps(['title'])
  defineEmits(['update:title'])
  </script>
  
  <template>
    <input
      type="text"
      :value="title"
      @input="$emit('update:title', $event.target.value)"
    />
  </template>
  ```

- [x] Fallthrough Attributes

  当我们直接在组件上添加一些 DOM 属性时，DOM的子元素会自动继承这些属性，如：

  ```vue
  <MyButton class="large" />
  ```

  组件实际会被渲染为：

  ```vue
  <button class="large">click me</button>
  ```

  如果我们想手动禁止属性的继承，可以配置上`inheritAttrs: false` 配置来阻止继承：

  ```vue
  <script>
  // use normal <script> to declare options
  export default {
    inheritAttrs: false
  }
  </script>
  
  <script setup>
  // ...setup logic
  </script>
  ```

  在`script setup`中，可以使用`useAttrs`，来获取组件的attrs属性集合，想到于 `$attrs`

  ```vue
  <script setup>
  import { useAttrs } from 'vue'
  
  const attrs = useAttrs()
  </script>
  ```

- [x] Slot

  在过去其实我一直对于`Slot`这个操作用的非常少（因为最早没学好，导致在开发时对于这个技术其实有一些抵触），我们不使用 slot ,就使用 `props` 一样也可以开发，但是那样有时候就不够优雅。

  slot 的概念有点像 react 中 props中的 children，简单的例子如下：

  ```vue
  <FancyButton>
    Click me! <!-- slot content -->
  </FancyButton>
  ```

  FancyButton组件内部：

  ```vue
  <button class="fancy-btn">
    <slot></slot> <!-- slot outlet --> 
  </button>
  ```

  实际上就会被渲染为：

  ```vue
  <button class="fancy-btn">
    Click me!
  </button>
  ```

  这种方式明显比 props 要优雅很多。

  **slot默认值**

  ```vue
  <button type="submit">
    <slot>
      Submit <!-- fallback content -->
    </slot>
  </button>
  ```

  此例子中，如果组件并没有传slot的值，则这时候默认会将 Submit 渲染出来，如果有传值则会将值渲染出来，这是一个兜底的方案。

  **name slot**

  假设我们有个 `BaseLoyout` 组件，其内部为：

  ```vue
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  ```

  那么在使用slot传值时就可以根据名字传值：

  ```vue
  <BaseLayout>
    <template #header>
      <h1>Here might be a page title</h1>
    </template>
  
    <template #default>
      <p>A paragraph for the main content.</p>
      <p>And another one.</p>
    </template>
  
    <template v-slot:footer>
      <p>Here's some contact info</p>
    </template>
  </BaseLayout>
  ```

  使用 `#header`  是一种简写方式，和`v-slot:header`是一样的，这个写法在`vantUI`中蛮多地方都这样写过。

- [x] Provider / Inject

  `Provider / Inject` 也是一种组件传值的方式，使用 `Provider` 共享一个值，则其的子孙组件都可以使用 `Inject` 来捕获到这个值，初看和 `vuex` 的概念好像有点像，其主要是为了解决像 props 一层一层传值时太过了复杂和繁琐了所以设计的这个API，只要是子孙组件就可以使用捕获到这个值。

  如果我们在最外层 `Provider` 值，其实就是一个全局状态了！

  其`provider` `reactive` 和 `ref` 时处理也会略微有一些不用，具体的可以再看文档复习一下。

  [provider / inject](https://vuejs.org/guide/components/provide-inject.html)

- [x] Async Component

  通过 `defineAsyncComponent` API 我们可以创建一个异步函数，基础用法如下：

  ```js
  import { defineAsyncComponent } from 'vue'
  
  const AsyncComp = defineAsyncComponent(() => {
    return new Promise((resolve, reject) => {
      // ...load component from server
      resolve(/* loaded component */)
    })
  })
  ```

  该函数返回的是一个Promise，所以我们其实是可以根据喝过API来实现一些懒加载的，尤其是当一些非常大型的项目的时候。

  **高阶用法 - 错误状态处理**

  ```js
  const AsyncComp = defineAsyncComponent({
    // the loader function
    loader: () => import('./Foo.vue'),
  
    // A component to use while the async component is loading
    loadingComponent: LoadingComponent,
    // Delay before showing the loading component. Default: 200ms.
    delay: 200,
  
    // A component to use if the load fails
    errorComponent: ErrorComponent,
    // The error component will be displayed if a timeout is
    // provided and exceeded. Default: Infinity.
    timeout: 3000
  })
  ```

  光看例子应该就蛮清晰的了，我们可以比较轻松的实现一个带有加载效果的异步的组件。

  所以下回面试官如果问如果实现懒加载等等之类的，异步组件也是一个回答。
  
- [x] Composables

  逻辑组合，在过去我们经常在一些常用的例子中写上一些重复的逻辑，在Vue3这个大版本下我们可以将这些逻辑做上组合，也就是 **组合API** ，上一个简单的例子：

  ```vue
  <script setup>
  import { ref, onMounted, onUnmounted } from 'vue'
  
  const x = ref(0)
  const y = ref(0)
  
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }
  
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))
  </script>
  
  <template>Mouse position is at: {{ x }}, {{ y }}</template>
  ```

  以上这个例子，如果我们要在其他组件中使用，在过去好像只能把这些代码大致的抄一下，但是在这个大版本下，我们就可以将其逻辑进行 **组合抽离**，组合成一个 `useMouse` 组合API:

  ```js
  // mouse.js
  import { ref, onMounted, onUnmounted } from 'vue'
  
  // by convention, composable function names start with "use"
  export function useMouse() {
    // state encapsulated and managed by the composable
    const x = ref(0)
    const y = ref(0)
  
    // a composable can update its managed state over time.
    function update(event) {
      x.value = event.pageX
      y.value = event.pageY
    }
  
    // a composable can also hook into its owner component's
    // lifecycle to setup and teardown side effects.
    onMounted(() => window.addEventListener('mousemove', update))
    onUnmounted(() => window.removeEventListener('mousemove', update))
  
    // expose managed state as return value
    return { x, y }
  }
  ```

  在需要使用的地方只要使用：

  ```vue
  <script setup>
  import { useMouse } from './mouse.js'
  
  const { x, y } = useMouse()
  </script>
  
  <template>Mouse position is at: {{ x }}, {{ y }}</template>
  ```

  简单了很多，但是也是有一些细节和一些组合的约定：

  - 所有的自定义封装的组合函数都以 `use`开头，如`useMouse`、`useFetch`
  - 组合API 返回的一个个值要用`ref`而不是`reactive`
  - 如果是一些SSR应用要注意，一些操作要在`onMounted`里执行，避免一些不必要的错误。

  如果我们在`optionAPI`中使用的，需要在`setup()`函数中使用：

  ```js
  import { useMouse } from './mouse.js'
  import { useFetch } from './fetch.js'
  
  export default {
    setup() {
      const { x, y } = useMouse()
      const { data, error } = useFetch('...')
      return { x, y, data, error }
    },
    mounted() {
      // setup() exposed properties can be accessed on `this`
      console.log(this.x)
    }
    // ...other options
  }
  ```

  **组合的一些优势**

  - 对比`mixin`，组合基本可以实现`mixin` 的所有能实现的内容，可以更加的方便，还可以避免一些不好的事情：

    - 来历不明的属性

      如果mixin使用多了，我们可能还需要判断一下一些属性是从哪里mixin来的，比较复杂

    - 命名空间的重复

      如果mixin的属性名和原本自身的属性名重复，也是会出现问题的。

  - 对比于 `react-hooks` 可能用起来是非常非常的像，但是这个组合是基于 vue自身的所有的响应式系统。本质上还是两个东西。

​	
