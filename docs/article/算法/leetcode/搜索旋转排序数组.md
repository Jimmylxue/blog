# 搜索旋转排序数组

::: tip 考点
难度：**中级**
:::

---

:::demo

```vue
<template>
  <div class="demo">
    <iframe
      src="//player.bilibili.com/player.html?aid=850413721&bvid=BV1aL4y1t75Q&cid=477449479&page=1"
      scrolling="no"
      border="0"
      frameborder="no"
      framespacing="0"
      allowfullscreen="true"
    >
    </iframe>
  </div>
</template>
<style>
.demo > iframe {
  width: 100%;
  height: 450px;
}
</style>
```

:::

### 题目

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1

### 解题思路

因为整个数组最对会被分成两个相对升序的数组

因为数组是升序的，所以我们在查找值时其实是有方法，在满足条件情况下就不用继续遍历了，所以总体上就是我们要规避掉不需要的操作

**解题原型**：

- 场景 1：小 => 大 => 小

  ![image-20220104192304623](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220104192304623.png)

- 场景 2：大 => 小

  ![image-20220104191403019](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220104191403019.png)

- 场景 3

  直接找到 target 指数输出即可

**总结步骤有以下几步**：

我们需要比对 目标值 和 遍历中的每个值的大小情况

- 当相等时，直接输出这个索引

- 当大小情况出现：小=>大=>小 的情况 不需要遍历 直接返回-1

- 当大小情况出现：大=>小 的情况 不需要遍历 直接返回-1

**细节**：

- 需要定义额外的变量来确定是先小后大，还是先大后小

**其他**

文档资料请到：http://www.jimmyxuexue.top:999/

源码请到公众号：Jimmy 前端 中获取
