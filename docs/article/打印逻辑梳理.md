# 打印逻辑梳理

Pc-pos 打印，逻辑上应用与后端通过websocket 连接。当用户下单之后，后端会推送一条打印消息给前端，前端再去执行一些打印的操作。

这些逻辑针对的是usb打印机和网口打印机，这两种统称为本地打印机，还有的就是云打印机，云打印机不属于本地讨论范围

## 逻辑入口

Render 层 下的 MainApp 组件下调用 `useNotifyMessage()` 这个hook，一切的逻辑入口在此。在此hook下执行websocket 连接，并接收ws消息。

打印的消息体数据结构如下：

```ts
enum PrintMessageType {
  receipt = 1,
  tag = 2 // 标签打印
}

type PrintContent = {
  content: string
  ip: string
  connectType: PrinterConnectType
  num: number
  id: number
  mType: PrintMessageType
  logoUrl?: string
}
```

当接收到ws传递的消息体之后，将其存入一个打印队列映射`printQueneMap`中，`printQueneMap`的结构如下：

```ts
const printQueneMap = new Map<string, Queue<() => {}>>()
// Queue 是队列 map 的key 是消息体的ip 或 id
```

逻辑上，每次接收到打印的消息体，我们都可以根据消息体的ip，或者id，来获取到对应的 Queue 队列。

之后就是执行打印的逻辑......

使用`usePrintService` 可以创建一个打印业务实例，再调用其的`print`方法执行打印。

```ts
async print(msg: MessageType, callback: (err?: any) => void) {
  if (msg.content) {
    try {
      const content = JSON.parse(msg.content)
      let num = content.num
      while (num) {
        await ipc.send('print', content) // 通过子进程
        num--
      }
      callback()
    } catch (err) {
      console.log(err)
      callback(err || '打印失败')
    }
  }
}
```

这里的核心可以看到是通过ipc创建一个进程，推送一个key 为 print，值为 content 的内容的信息给主线程。

## 主进程的操作

electron主进程中监听了`print`消息。

```ts
@Controller()
export class AppController {
	@IpcInvoke('print')
  public async handlePrint(printContent: PrintContent) {
    await PrintService.print(printContent)
  }
}
```

这里我们可以看到，真正处理打印消息的是`PrintService`这个对象，这个对象上也有一个`print`方法。

有了打印的内容，接下来就是需要获取打印设备了，只要我们能够捕获到打印设备，逻辑上调用打印设备的打印方法，将打印内容传递进去，就可以实现打印了。

以上有说我们针对的是，网口打印机、usb打印机。所以这里两块的处理是不同的。

以上这里都用到了`escpos`这个库。

- 获取网口打印机

  网口打印机都有独立的ip，所以逻辑上是根据ip来获取到这个打印机。

  ```ts
  function getNetworkPrinter(deviceIp: string) {
      try {
        const config = this.networkPrinterConfigs[deviceIp]
        if (!config?.ip) {
          return
        }
        const [ip, port = 9100] = config!.ip.split(':')
        const networkDevice = new escpos.Network(ip, port)
        const options = { encoding: "GB18030" /* default */, width: config.paperWidth || 80 }
        if (!networkDevice) {
          return
        }
        const printer = new escpos.Printer(networkDevice, options);
        return {
          device: networkDevice,
          printer,
          config
        }
      } catch (err) {
        console.log(err)
      }
    }
  ```

- 获取usb打印机

  本地打印机都有独立的id，系统也是会通过`escpos`这个库去查找打印机。并存下来，之后再通过id 可以获取到打印机。

  ```ts
  function getPrinterById(id: number | string): {
    device: any,
    printer: any,
    config?: PrinterConfig
  } | undefined {
    if (this.printers[id]) {
      return this.printers[id]
    }
  
    try {
      const defaultConifgId = Object.keys(this.printers)[0]
      const config = defaultConifgId && this.printers[defaultConifgId]
      return this.getPrinter(config)
    } catch (err) {
      console.log(err)
      return
    }
  }
  ```

获取到了打印机、打印内容之后，就可以调用打印机的打印方法了。

```ts
async function handlePrint({ printer, content, logoUrl, callback = () => { }, paperWidth = 58 }) {
  const dom = htmlparser2.parseDocument(content);
  const printCommends = dom.children
  
  const resolveNode = async (node) => {
   // 执行具体的打印指令 
  }
  
  for (let node of printCommends) {
    await resolveNode(node)
  }

  printer.newLine()
  printer.newLine()
  printer.cut()

  // 3 声蜂鸣，每次300ms
  printer.beep(3, 3)

  printer.close(callback)
  console.log('print success')
}
```

逻辑中每打印一个字符都是通过调用`printer.raw()`实现的。

```ts
const write = (bytes)=>{
  const buffer = new MutableBuffer()
  buffer.write(bytes)
  printer.raw(buffer.flush())
}

// 设置字体加粗
const setFontWeight = (byte = 0x00) => {
  write([0x1b, 0x45, byte])
}

// 设置字体大小
const setFontSize = (byte = 0x0000) => {
  write([0x1d, 0x21, byte])
}

const doubleHeight = () => {
  setFontSize(0x01)
}

const doubleWidth = () => {
  setFontSize(0x10)
}

const doubleSize = () => {
  setFontSize(0x11)
}
```





