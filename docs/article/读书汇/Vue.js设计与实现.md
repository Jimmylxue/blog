---
head:
  - - meta
    - name: description
      content: Vue.js设计与实现

  - - meta
    - name: keywords
      content: Vue.js设计与实现
---

# Vue.js设计与实现

等了好几天这本书终于到了，这是我买得第一本框架类的书籍，这篇文章中我将陆续的记录从这本书中学到的知识。

![image-20220613220644914](https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220613220644914.png)

## 权衡的艺术

> 框架设计里到处都体现了权衡的艺术

### 命令式和声明式

老实说，我还真不知道什么是命令式代码和声明式代码，看完这一小节之后我的感觉是这个和过去所知道的 **面向对象**和 **面相过程**是有点儿像的，其中就举了一个简答的例子。

命令式的代码：

```js
const div = document.querySelector('div')
div.innerText = 'hello world'
div.addEventListener('click', ()=>{ alert('hello') })
```

 声明式的代码：

```vue
<div @click="()=>alert('hello')">hello world</div>
```

以上的代码就是简单的给`DOM`设置文本同时添加点击事件，命令式代码我们注重过程，会一步步的实现，而声明式的代码我们只需要告诉代码或者编辑器，我们想怎么样，真正的过程vue都帮我们做好了。

**过去的误区 : 虚拟DOM性能更高，真实DOM更消耗性能**

可能因为之前背面试题背多了，导致会有这种想法，这里就像作者说的，上面的那个例子就是典型的一个反例代表了，如果我们就想实现设置文本，再添加点击事件，有比命令式代码性能更高的操作方法吗？

只怕是没有，因为上面声明式的代码每步也都是做定向的修改操作！而下面声明式的代码，多了一个编辑解析的过程，（要能编译‘@’点击事件），所以下面的性能是肯定没有上面的性能高的，但是下面代码更加利于开发和维护（想象一下如果有几十个这种差不多操作需求，明显下面的更利于维护）

所以！vue或者说那些框架做的，实际是在 **保持代码维护体验性的同时，尽量让性能损失降低到最小**

总结：

- 命令式的代码性能消耗为A
- 声明式的代码性能消耗为B+A (B是编译的那个过程)

**虚拟DOM的优势体现在更新**

比较一下这样一个代码（过去我确实写过）：

```js
const html = `<div><span>112233</span></div>`
const div = document.querySelector('div')
div.innerHTML = html
```

每当我们使用innerHTML去修改DOM这个是极其消耗性能的，因为innerHTML的过程会去试图解析字符串，转成可用的DOM树，之后再插入文档（非常的消耗性能），而当我们数据发生改变，再次使用innerHTML操作的时候等于又要再执行一次，所以这种场景就是 **原生操作DOM消耗性能的场景**

而虚拟DOM在更新的时候会生成一个新的JS的DOM对象，再去比对前一次和这一次的DOM对象的差别，只修改差别的地方（这里就少了渲染DOM树，和插入的过程），所以这就是虚拟DOM的优势。